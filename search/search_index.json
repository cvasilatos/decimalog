{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Decima","text":"<p>Decima is a robust, custom logging library for Python that enhances your application's observability with colorful console output and structured JSON logging. Designed for clarity and ease of use, it helps developers track down issues faster with a dedicated <code>TRACE</code> level and automatic file management.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83c\udfa8 Colorful Console Output: Instantly distinguish log levels with vibrant color coding (Cyan for TRACE, Blue for DEBUG, Red for ERROR, etc.).</li> <li>\ud83d\udcca Structured JSON Logging: Automatically writes logs to <code>.jsonl</code> files, perfect for ingestion by log analysis tools.</li> <li>\ud83d\udd0d Custom TRACE Level: Includes a <code>TRACE</code> (level 5) severity for ultra-granular debugging, below the standard <code>DEBUG</code>.</li> <li>\ud83d\udcc1 Automated File Management: seamlessly handles log file creation, including timestamped run logs and cumulative JSON logs.</li> <li>\u26a1 Simple Configuration: Get up and running with a single static setup call.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Decima is a Python library managed with modern tooling. You can install it using <code>pip</code> or <code>uv</code>:</p> <pre><code># Using pip\npip install decima\n\n# Using uv\nuv add decima\n</code></pre> <p>(Note: Adjust installation command based on your package registry status. If running locally, ensure you build and install the wheel.)</p>"},{"location":"#usage","title":"Usage","text":"<p>Integrating Decima into your project is straightforward.</p>"},{"location":"#1-setup-logging","title":"1. Setup Logging","text":"<p>Initialize the logger at the start of your application entry point:</p> <pre><code>import logging\nfrom decima import CustomLogger\n\n# Configure logging:\n# - folder: Directory to store log files\n# - filename: Base name for log files\n# - level: Minimum logging level (e.g., \"DEBUG\", \"INFO\")\n# - class_length: Max length for logger name in console output (for alignment)\nCustomLogger.setup_logging(\n    folder=\"logs\",\n    filename=\"app\",\n    level=\"DEBUG\",\n    class_length=20\n)\n\n# Get a logger instance\nlogger = logging.getLogger(\"MyApp\")\n</code></pre>"},{"location":"#2-logging-messages","title":"2. Logging Messages","text":"<p>You can now use the standard logging methods, plus the new <code>trace</code> method (if using <code>CustomLogger</code> explicitly or if the level is registered):</p> <pre><code>logger.info(\"Application started successfully.\")\nlogger.warning(\"Configuration file missing, using defaults.\")\nlogger.error(\"Failed to connect to database.\")\n\n# For Trace level (level 5)\n# Note: Ensure usage complies with the CustomLogger class capabilities\ncustom_logger = logging.getLogger(\"MyApp\")\nif isinstance(custom_logger, CustomLogger):\n    custom_logger.trace(\"Entering complex calculation loop...\")\n</code></pre> <p>To fully utilize the <code>trace</code> method with type safety, you might want to ensure your logger is typed as <code>CustomLogger</code>.</p>"},{"location":"#output-formats","title":"Output Formats","text":"<p>Console Output:</p> <pre><code>2023-10-27 10:00:00,123 - [INFO] - MyApp - Application started successfully.\n</code></pre> <p>(With appropriate colors applied)</p> <p>JSON Output (<code>logs/app.jsonl</code>):</p> <pre><code>{\"timestamp\": \"2023-10-27T10:00:00.123456-05:00\", \"level\": \"INFO\", \"name\": \"MyApp\", \"message\": \"Application started successfully.\"}\n</code></pre>"},{"location":"#specific-configuration","title":"specific Configuration","text":"<ul> <li><code>LogFormatter</code>: Handles the colorization and formatting of console logs.</li> <li><code>JsonFormatter</code>: Handles the serialization of log records into JSON structure.</li> <li><code>class_length</code>: Truncates the logger name in the console output to keep columns aligned, preserving the end of the name.</li> </ul>"},{"location":"#development","title":"Development","text":"<p>This project uses <code>uv</code> for dependency management and <code>hatch</code> for building.</p>"},{"location":"#setting-up-the-environment","title":"Setting up the environment","text":"<pre><code>uv sync --all-extras --dev\n</code></pre>"},{"location":"#running-tests","title":"Running Tests","text":"<pre><code>uv run pytest\n</code></pre>"},{"location":"#linting-formatting","title":"Linting &amp; Formatting","text":"<pre><code>uv run ruff check .\nuv run ruff format .\n</code></pre>"},{"location":"#building-documentation","title":"Building Documentation","text":"<p>Decima uses <code>mkdocs</code> for documentation.</p> <pre><code>uv run mkdocs serve\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for details.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#logger.CustomLogger","title":"<code>CustomLogger</code>","text":"<p>               Bases: <code>Logger</code></p> <p>Custom logger that supports a TRACE level and sets up logging with both console and file handlers.</p> Source code in <code>src/decima/logger.py</code> <pre><code>class CustomLogger(logging.Logger):\n    \"\"\"Custom logger that supports a TRACE level and sets up logging with both console and file handlers.\"\"\"\n\n    TRACE: ClassVar[int] = 5\n    logging.addLevelName(TRACE, \"TRACE\")\n\n    def trace(self, msg: str, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ANN401\n        \"\"\"Log a message with severity 'TRACE'.\"\"\"\n        if self.isEnabledFor(self.TRACE):\n            self._log(self.TRACE, msg, args, **kwargs)\n\n    @staticmethod\n    def setup_logging(folder: str, filename: str, level: str, class_length: int) -&gt; None:\n        \"\"\"Set up logging with a console handler that uses the custom LogFormatter and a file handler that writes logs in JSON format using the JsonFormatter.\"\"\"\n        logging.setLoggerClass(CustomLogger)\n\n        root: logging.Logger = logging.getLogger()\n        for handler in root.handlers[:]:\n            root.removeHandler(handler)\n\n        log_dir = Path(folder)\n        log_dir.mkdir(parents=True, exist_ok=True)\n        date_time: str = datetime.now(tz=datetime.now().astimezone().tzinfo).strftime(\"%Y%m%d-%H%M%S\")\n        file_handler = logging.FileHandler(log_dir / f\"{filename}-{date_time}.log\", mode=\"w\")\n        file_handler.setFormatter(logging.Formatter(LogFormatter.fmt_str))\n\n        console_handler: logging.StreamHandler[TextIO] = logging.StreamHandler()\n        console_handler.setFormatter(LogFormatter(class_length))\n\n        log_path: Path = Path(folder) / f\"{filename}.jsonl\"\n        file_h = logging.FileHandler(log_path, mode=\"a\")\n        file_h.setFormatter(JsonFormatter())\n\n        logging.basicConfig(level=level, handlers=[console_handler, file_handler, file_h])\n</code></pre>"},{"location":"api/#logger.CustomLogger.setup_logging","title":"<code>setup_logging(folder, filename, level, class_length)</code>  <code>staticmethod</code>","text":"<p>Set up logging with a console handler that uses the custom LogFormatter and a file handler that writes logs in JSON format using the JsonFormatter.</p> Source code in <code>src/decima/logger.py</code> <pre><code>@staticmethod\ndef setup_logging(folder: str, filename: str, level: str, class_length: int) -&gt; None:\n    \"\"\"Set up logging with a console handler that uses the custom LogFormatter and a file handler that writes logs in JSON format using the JsonFormatter.\"\"\"\n    logging.setLoggerClass(CustomLogger)\n\n    root: logging.Logger = logging.getLogger()\n    for handler in root.handlers[:]:\n        root.removeHandler(handler)\n\n    log_dir = Path(folder)\n    log_dir.mkdir(parents=True, exist_ok=True)\n    date_time: str = datetime.now(tz=datetime.now().astimezone().tzinfo).strftime(\"%Y%m%d-%H%M%S\")\n    file_handler = logging.FileHandler(log_dir / f\"{filename}-{date_time}.log\", mode=\"w\")\n    file_handler.setFormatter(logging.Formatter(LogFormatter.fmt_str))\n\n    console_handler: logging.StreamHandler[TextIO] = logging.StreamHandler()\n    console_handler.setFormatter(LogFormatter(class_length))\n\n    log_path: Path = Path(folder) / f\"{filename}.jsonl\"\n    file_h = logging.FileHandler(log_path, mode=\"a\")\n    file_h.setFormatter(JsonFormatter())\n\n    logging.basicConfig(level=level, handlers=[console_handler, file_handler, file_h])\n</code></pre>"},{"location":"api/#logger.CustomLogger.trace","title":"<code>trace(msg, *args, **kwargs)</code>","text":"<p>Log a message with severity 'TRACE'.</p> Source code in <code>src/decima/logger.py</code> <pre><code>def trace(self, msg: str, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ANN401\n    \"\"\"Log a message with severity 'TRACE'.\"\"\"\n    if self.isEnabledFor(self.TRACE):\n        self._log(self.TRACE, msg, args, **kwargs)\n</code></pre>"},{"location":"api/#logger.JsonFormatter","title":"<code>JsonFormatter</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>Log formatter that outputs logs in JSON format, including timestamp, level, name, message, and any extra data.</p> Source code in <code>src/decima/logger.py</code> <pre><code>class JsonFormatter(logging.Formatter):\n    \"\"\"Log formatter that outputs logs in JSON format, including timestamp, level, name, message, and any extra data.\"\"\"\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n        \"\"\"Format the log record as a JSON string, including timestamp, level, name, message, and any extra data if provided.\"\"\"\n        log_record: dict[str, Any] = {\n            \"timestamp\": datetime.fromtimestamp(record.created, tz=datetime.now().astimezone().tzinfo).isoformat(),\n            \"level\": record.levelname,\n            \"name\": record.name,\n            \"message\": record.getMessage(),\n        }\n        # If the user passed extra={} data, include it\n        if hasattr(record, \"extra_data\"):\n            log_record[\"extra\"] = getattr(record, \"extra_data\", None)\n\n        return json.dumps(log_record)\n</code></pre>"},{"location":"api/#logger.JsonFormatter.format","title":"<code>format(record)</code>","text":"<p>Format the log record as a JSON string, including timestamp, level, name, message, and any extra data if provided.</p> Source code in <code>src/decima/logger.py</code> <pre><code>def format(self, record: logging.LogRecord) -&gt; str:\n    \"\"\"Format the log record as a JSON string, including timestamp, level, name, message, and any extra data if provided.\"\"\"\n    log_record: dict[str, Any] = {\n        \"timestamp\": datetime.fromtimestamp(record.created, tz=datetime.now().astimezone().tzinfo).isoformat(),\n        \"level\": record.levelname,\n        \"name\": record.name,\n        \"message\": record.getMessage(),\n    }\n    # If the user passed extra={} data, include it\n    if hasattr(record, \"extra_data\"):\n        log_record[\"extra\"] = getattr(record, \"extra_data\", None)\n\n    return json.dumps(log_record)\n</code></pre>"},{"location":"api/#logger.LogFormatter","title":"<code>LogFormatter</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>Log formatter that adds colors based on log levels.</p> Source code in <code>src/decima/logger.py</code> <pre><code>class LogFormatter(logging.Formatter):\n    \"\"\"Log formatter that adds colors based on log levels.\"\"\"\n\n    def __init__(self, class_length: int) -&gt; None:\n        \"\"\"Initialize the LogFormatter with a specified class name length for formatting.\"\"\"\n        super().__init__()\n        self.class_length: int = class_length\n\n    cyan, blue, gray, yellow, red, bold_red = (\n        \"\\x1b[36m\",\n        \"\\x1b[34m\",\n        \"\\x1b[37m\",\n        \"\\x1b[33m\",\n        \"\\x1b[31m\",\n        \"\\x1b[31;1m\",\n    )\n    reset = \"\\x1b[0m\"\n\n    bold = \"\\033[1m\"\n    reset_bold = \"\\033[0m\"\n\n    fmt_str = f\"%(asctime)s - [%(levelname)s] - {bold}%(name)s{reset_bold} - %(message)s\"\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n        \"\"\"Format the log record with colors based on the log level and ensure the logger name is at most 15 characters long.\"\"\"\n        if len(record.name) &gt; self.class_length:\n            record.name = record.name[-self.class_length :]\n\n        formats = {\n            5: f\"{self.cyan}{self.fmt_str}{self.reset}\",\n            logging.DEBUG: f\"{self.blue}{self.fmt_str}{self.reset}\",\n            logging.INFO: f\"{self.gray}{self.fmt_str}{self.reset}\",\n            logging.WARNING: f\"{self.yellow}{self.fmt_str}{self.reset}\",\n            logging.ERROR: f\"{self.red}{self.fmt_str}{self.reset}\",\n            logging.CRITICAL: f\"{self.bold_red}{self.fmt_str}{self.reset}\",\n        }\n        log_fmt = formats.get(record.levelno, self.fmt_str)\n\n        return logging.Formatter(log_fmt).format(record)\n</code></pre>"},{"location":"api/#logger.LogFormatter.__init__","title":"<code>__init__(class_length)</code>","text":"<p>Initialize the LogFormatter with a specified class name length for formatting.</p> Source code in <code>src/decima/logger.py</code> <pre><code>def __init__(self, class_length: int) -&gt; None:\n    \"\"\"Initialize the LogFormatter with a specified class name length for formatting.\"\"\"\n    super().__init__()\n    self.class_length: int = class_length\n</code></pre>"},{"location":"api/#logger.LogFormatter.format","title":"<code>format(record)</code>","text":"<p>Format the log record with colors based on the log level and ensure the logger name is at most 15 characters long.</p> Source code in <code>src/decima/logger.py</code> <pre><code>def format(self, record: logging.LogRecord) -&gt; str:\n    \"\"\"Format the log record with colors based on the log level and ensure the logger name is at most 15 characters long.\"\"\"\n    if len(record.name) &gt; self.class_length:\n        record.name = record.name[-self.class_length :]\n\n    formats = {\n        5: f\"{self.cyan}{self.fmt_str}{self.reset}\",\n        logging.DEBUG: f\"{self.blue}{self.fmt_str}{self.reset}\",\n        logging.INFO: f\"{self.gray}{self.fmt_str}{self.reset}\",\n        logging.WARNING: f\"{self.yellow}{self.fmt_str}{self.reset}\",\n        logging.ERROR: f\"{self.red}{self.fmt_str}{self.reset}\",\n        logging.CRITICAL: f\"{self.bold_red}{self.fmt_str}{self.reset}\",\n    }\n    log_fmt = formats.get(record.levelno, self.fmt_str)\n\n    return logging.Formatter(log_fmt).format(record)\n</code></pre>"}]}
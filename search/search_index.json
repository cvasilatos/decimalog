{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Decima Decima is a robust, custom logging library for Python that enhances your application's observability with colorful console output and structured JSON logging. Designed for clarity and ease of use, it helps developers track down issues faster with a dedicated TRACE level and automatic file management. Key Features \ud83c\udfa8 Colorful Console Output : Instantly distinguish log levels with vibrant color coding (Cyan for TRACE, Blue for DEBUG, Red for ERROR, etc.). \ud83d\udcca Structured JSON Logging : Automatically writes logs to .jsonl files, perfect for ingestion by log analysis tools. \ud83d\udd0d Custom TRACE Level : Includes a TRACE (level 5) severity for ultra-granular debugging, below the standard DEBUG . \ud83d\udcc1 Automated File Management : seamlessly handles log file creation, including timestamped run logs and cumulative JSON logs. \u26a1 Simple Configuration : Get up and running with a single static setup call. Installation Decima is a Python library. Since it is not yet on PyPI, you can install it directly from the git repository using pip or uv : # Using pip pip install \"git+https://github.com/cvasilatos/decima.git\" # Using uv uv add \"git+https://github.com/cvasilatos/decima.git\" (Note: Adjust installation command based on your package registry status. If running locally, ensure you build and install the wheel.) Usage Integrating Decima into your project is straightforward. 1. Setup Logging Initialize the logger at the start of your application entry point: import logging from decima import CustomLogger # Configure logging: # - folder: Directory to store log files # - filename: Base name for log files # - level: Minimum logging level (e.g., \"DEBUG\", \"INFO\") # - class_length: Max length for logger name in console output (for alignment) CustomLogger.setup_logging( folder=\"logs\", filename=\"app\", level=\"DEBUG\", class_length=20 ) # Get a logger instance logger = logging.getLogger(\"MyApp\") 2. Logging Messages You can now use the standard logging methods, plus the new trace method (if using CustomLogger explicitly or if the level is registered): logger.info(\"Application started successfully.\") logger.warning(\"Configuration file missing, using defaults.\") logger.error(\"Failed to connect to database.\") # For Trace level (level 5) # Note: Ensure usage complies with the CustomLogger class capabilities custom_logger = logging.getLogger(\"MyApp\") if isinstance(custom_logger, CustomLogger): custom_logger.trace(\"Entering complex calculation loop...\") To fully utilize the trace method with type safety, you might want to ensure your logger is typed as CustomLogger . Output Formats Console Output: 2023-10-27 10:00:00,123 - [INFO] - MyApp - Application started successfully. (With appropriate colors applied) JSON Output ( logs/app.jsonl ): {\"timestamp\": \"2023-10-27T10:00:00.123456-05:00\", \"level\": \"INFO\", \"name\": \"MyApp\", \"message\": \"Application started successfully.\"} specific Configuration LogFormatter : Handles the colorization and formatting of console logs. JsonFormatter : Handles the serialization of log records into JSON structure. class_length : Truncates the logger name in the console output to keep columns aligned, preserving the end of the name. Development This project uses uv for dependency management and hatch for building. Setting up the environment uv sync --all-extras --dev Running Tests uv run pytest Linting & Formatting uv run ruff check . uv run ruff format . Building Documentation Decima uses mkdocs for documentation. uv run mkdocs serve License This project is licensed under the MIT License. See the LICENSE file for details.","title":"Home"},{"location":"#decima","text":"Decima is a robust, custom logging library for Python that enhances your application's observability with colorful console output and structured JSON logging. Designed for clarity and ease of use, it helps developers track down issues faster with a dedicated TRACE level and automatic file management.","title":"Decima"},{"location":"#key-features","text":"\ud83c\udfa8 Colorful Console Output : Instantly distinguish log levels with vibrant color coding (Cyan for TRACE, Blue for DEBUG, Red for ERROR, etc.). \ud83d\udcca Structured JSON Logging : Automatically writes logs to .jsonl files, perfect for ingestion by log analysis tools. \ud83d\udd0d Custom TRACE Level : Includes a TRACE (level 5) severity for ultra-granular debugging, below the standard DEBUG . \ud83d\udcc1 Automated File Management : seamlessly handles log file creation, including timestamped run logs and cumulative JSON logs. \u26a1 Simple Configuration : Get up and running with a single static setup call.","title":"Key Features"},{"location":"#installation","text":"Decima is a Python library. Since it is not yet on PyPI, you can install it directly from the git repository using pip or uv : # Using pip pip install \"git+https://github.com/cvasilatos/decima.git\" # Using uv uv add \"git+https://github.com/cvasilatos/decima.git\" (Note: Adjust installation command based on your package registry status. If running locally, ensure you build and install the wheel.)","title":"Installation"},{"location":"#usage","text":"Integrating Decima into your project is straightforward.","title":"Usage"},{"location":"#1-setup-logging","text":"Initialize the logger at the start of your application entry point: import logging from decima import CustomLogger # Configure logging: # - folder: Directory to store log files # - filename: Base name for log files # - level: Minimum logging level (e.g., \"DEBUG\", \"INFO\") # - class_length: Max length for logger name in console output (for alignment) CustomLogger.setup_logging( folder=\"logs\", filename=\"app\", level=\"DEBUG\", class_length=20 ) # Get a logger instance logger = logging.getLogger(\"MyApp\")","title":"1. Setup Logging"},{"location":"#2-logging-messages","text":"You can now use the standard logging methods, plus the new trace method (if using CustomLogger explicitly or if the level is registered): logger.info(\"Application started successfully.\") logger.warning(\"Configuration file missing, using defaults.\") logger.error(\"Failed to connect to database.\") # For Trace level (level 5) # Note: Ensure usage complies with the CustomLogger class capabilities custom_logger = logging.getLogger(\"MyApp\") if isinstance(custom_logger, CustomLogger): custom_logger.trace(\"Entering complex calculation loop...\") To fully utilize the trace method with type safety, you might want to ensure your logger is typed as CustomLogger .","title":"2. Logging Messages"},{"location":"#output-formats","text":"Console Output: 2023-10-27 10:00:00,123 - [INFO] - MyApp - Application started successfully. (With appropriate colors applied) JSON Output ( logs/app.jsonl ): {\"timestamp\": \"2023-10-27T10:00:00.123456-05:00\", \"level\": \"INFO\", \"name\": \"MyApp\", \"message\": \"Application started successfully.\"}","title":"Output Formats"},{"location":"#specific-configuration","text":"LogFormatter : Handles the colorization and formatting of console logs. JsonFormatter : Handles the serialization of log records into JSON structure. class_length : Truncates the logger name in the console output to keep columns aligned, preserving the end of the name.","title":"specific Configuration"},{"location":"#development","text":"This project uses uv for dependency management and hatch for building.","title":"Development"},{"location":"#setting-up-the-environment","text":"uv sync --all-extras --dev","title":"Setting up the environment"},{"location":"#running-tests","text":"uv run pytest","title":"Running Tests"},{"location":"#linting-formatting","text":"uv run ruff check . uv run ruff format .","title":"Linting &amp; Formatting"},{"location":"#building-documentation","text":"Decima uses mkdocs for documentation. uv run mkdocs serve","title":"Building Documentation"},{"location":"#license","text":"This project is licensed under the MIT License. See the LICENSE file for details.","title":"License"},{"location":"api/","text":"API Reference CustomLogger Bases: Logger Custom logger that supports a TRACE level and sets up logging with both console and file handlers. Source code in src/decima/logger.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class CustomLogger ( logging . Logger ): \"\"\"Custom logger that supports a TRACE level and sets up logging with both console and file handlers.\"\"\" TRACE : ClassVar [ int ] = 5 logging . addLevelName ( TRACE , \"TRACE\" ) def trace ( self , msg : str , * args : Any , ** kwargs : Any ) -> None : # noqa: ANN401 \"\"\"Log a message with severity 'TRACE'.\"\"\" if self . isEnabledFor ( self . TRACE ): self . _log ( self . TRACE , msg , args , ** kwargs ) @staticmethod def setup_logging ( folder : str , filename : str , level : str , class_length : int ) -> None : \"\"\"Set up logging with a handler that uses the custom LogFormatter and a file handler that writes logs in JSON format using the JsonFormatter. Args: folder (str): The directory where log files will be stored. If the directory does not exist, it will be created. filename (str): The base name for the log files. The actual log file will include a timestamp to ensure uniqueness. level (str): The logging level (e.g., \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\") that determines the minimum severity of messages to be logged. class_length (int): The maximum length of the logger name to display in the log output. If the logger name exceeds this length, it will be truncated from the left. Description: - This method configures the logging system to use a custom logger class (CustomLogger) and sets up two handlers: a console handler that formats logs with colors based on log levels, and \"\"\" logging . setLoggerClass ( CustomLogger ) root : logging . Logger = logging . getLogger () for handler in root . handlers [:]: root . removeHandler ( handler ) log_dir = Path ( folder ) log_dir . mkdir ( parents = True , exist_ok = True ) date_time : str = datetime . now ( tz = datetime . now () . astimezone () . tzinfo ) . strftime ( \"%Y%m %d -%H%M%S\" ) file_handler = logging . FileHandler ( log_dir / f \" { filename } - { date_time } .log\" , mode = \"w\" ) file_handler . setFormatter ( logging . Formatter ( LogFormatter . fmt_str )) console_handler : logging . StreamHandler [ TextIO ] = logging . StreamHandler () console_handler . setFormatter ( LogFormatter ( class_length )) log_path : Path = Path ( folder ) / f \" { filename } .jsonl\" file_h = logging . FileHandler ( log_path , mode = \"a\" ) file_h . setFormatter ( JsonFormatter ()) logging . basicConfig ( level = level , handlers = [ console_handler , file_handler , file_h ]) setup_logging ( folder , filename , level , class_length ) staticmethod Set up logging with a handler that uses the custom LogFormatter and a file handler that writes logs in JSON format using the JsonFormatter. Parameters: folder ( str ) \u2013 The directory where log files will be stored. If the directory does not exist, it will be created. filename ( str ) \u2013 The base name for the log files. The actual log file will include a timestamp to ensure uniqueness. level ( str ) \u2013 The logging level (e.g., \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\") that determines the minimum severity of messages to be logged. class_length ( int ) \u2013 The maximum length of the logger name to display in the log output. If the logger name exceeds this length, it will be truncated from the left. Description This method configures the logging system to use a custom logger class (CustomLogger) and sets up two handlers: a console handler that formats logs with colors based on log levels, and Source code in src/decima/logger.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 @staticmethod def setup_logging ( folder : str , filename : str , level : str , class_length : int ) -> None : \"\"\"Set up logging with a handler that uses the custom LogFormatter and a file handler that writes logs in JSON format using the JsonFormatter. Args: folder (str): The directory where log files will be stored. If the directory does not exist, it will be created. filename (str): The base name for the log files. The actual log file will include a timestamp to ensure uniqueness. level (str): The logging level (e.g., \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\") that determines the minimum severity of messages to be logged. class_length (int): The maximum length of the logger name to display in the log output. If the logger name exceeds this length, it will be truncated from the left. Description: - This method configures the logging system to use a custom logger class (CustomLogger) and sets up two handlers: a console handler that formats logs with colors based on log levels, and \"\"\" logging . setLoggerClass ( CustomLogger ) root : logging . Logger = logging . getLogger () for handler in root . handlers [:]: root . removeHandler ( handler ) log_dir = Path ( folder ) log_dir . mkdir ( parents = True , exist_ok = True ) date_time : str = datetime . now ( tz = datetime . now () . astimezone () . tzinfo ) . strftime ( \"%Y%m %d -%H%M%S\" ) file_handler = logging . FileHandler ( log_dir / f \" { filename } - { date_time } .log\" , mode = \"w\" ) file_handler . setFormatter ( logging . Formatter ( LogFormatter . fmt_str )) console_handler : logging . StreamHandler [ TextIO ] = logging . StreamHandler () console_handler . setFormatter ( LogFormatter ( class_length )) log_path : Path = Path ( folder ) / f \" { filename } .jsonl\" file_h = logging . FileHandler ( log_path , mode = \"a\" ) file_h . setFormatter ( JsonFormatter ()) logging . basicConfig ( level = level , handlers = [ console_handler , file_handler , file_h ]) trace ( msg , * args , ** kwargs ) Log a message with severity 'TRACE'. Source code in src/decima/logger.py 82 83 84 85 def trace ( self , msg : str , * args : Any , ** kwargs : Any ) -> None : # noqa: ANN401 \"\"\"Log a message with severity 'TRACE'.\"\"\" if self . isEnabledFor ( self . TRACE ): self . _log ( self . TRACE , msg , args , ** kwargs ) JsonFormatter Bases: Formatter Log formatter that outputs logs in JSON format, including timestamp, level, name, message, and any extra data. Source code in src/decima/logger.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class JsonFormatter ( logging . Formatter ): \"\"\"Log formatter that outputs logs in JSON format, including timestamp, level, name, message, and any extra data.\"\"\" def format ( self , record : logging . LogRecord ) -> str : \"\"\"Format the log record as a JSON string, including timestamp, level, name, message, and any extra data if provided.\"\"\" log_record : dict [ str , Any ] = { \"timestamp\" : datetime . fromtimestamp ( record . created , tz = datetime . now () . astimezone () . tzinfo ) . isoformat (), \"level\" : record . levelname , \"name\" : record . name , \"message\" : record . getMessage (), } # If the user passed extra={} data, include it if hasattr ( record , \"extra_data\" ): log_record [ \"extra\" ] = getattr ( record , \"extra_data\" , None ) return json . dumps ( log_record ) format ( record ) Format the log record as a JSON string, including timestamp, level, name, message, and any extra data if provided. Source code in src/decima/logger.py 61 62 63 64 65 66 67 68 69 70 71 72 73 def format ( self , record : logging . LogRecord ) -> str : \"\"\"Format the log record as a JSON string, including timestamp, level, name, message, and any extra data if provided.\"\"\" log_record : dict [ str , Any ] = { \"timestamp\" : datetime . fromtimestamp ( record . created , tz = datetime . now () . astimezone () . tzinfo ) . isoformat (), \"level\" : record . levelname , \"name\" : record . name , \"message\" : record . getMessage (), } # If the user passed extra={} data, include it if hasattr ( record , \"extra_data\" ): log_record [ \"extra\" ] = getattr ( record , \"extra_data\" , None ) return json . dumps ( log_record ) LogFormatter Bases: Formatter Log formatter that adds colors based on log levels. Source code in src/decima/logger.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class LogFormatter ( logging . Formatter ): \"\"\"Log formatter that adds colors based on log levels.\"\"\" def __init__ ( self , class_length : int ) -> None : \"\"\"Initialize the LogFormatter with a specified class name length for formatting. Args: class_length (int): The maximum length of the logger name to display in the log output. If the logger name exceeds this length, it will be truncated from the left. Notes: - The formatter will apply different colors to the log output based on the log level (e.g., TRACE, DEBUG, INFO, WARNING, ERROR, CRITICAL). - The log format includes the timestamp, log level, logger name (formatted with bold), and the log message. \"\"\" super () . __init__ () self . class_length : int = class_length cyan , blue , gray , yellow , red , bold_red = ( \" \\x1b [36m\" , \" \\x1b [34m\" , \" \\x1b [37m\" , \" \\x1b [33m\" , \" \\x1b [31m\" , \" \\x1b [31;1m\" , ) reset = \" \\x1b [0m\" bold = \" \\033 [1m\" reset_bold = \" \\033 [0m\" fmt_str = f \"%(asctime)s - [%(levelname)s] - { bold } %(name)s { reset_bold } - %(message)s\" def format ( self , record : logging . LogRecord ) -> str : \"\"\"Override the format method to apply color formatting based on log levels and truncate logger names if they exceed the specified class length.\"\"\" if len ( record . name ) > self . class_length : record . name = record . name [ - self . class_length :] formats = { 5 : f \" { self . cyan }{ self . fmt_str }{ self . reset } \" , logging . DEBUG : f \" { self . blue }{ self . fmt_str }{ self . reset } \" , logging . INFO : f \" { self . gray }{ self . fmt_str }{ self . reset } \" , logging . WARNING : f \" { self . yellow }{ self . fmt_str }{ self . reset } \" , logging . ERROR : f \" { self . red }{ self . fmt_str }{ self . reset } \" , logging . CRITICAL : f \" { self . bold_red }{ self . fmt_str }{ self . reset } \" , } log_fmt = formats . get ( record . levelno , self . fmt_str ) return logging . Formatter ( log_fmt ) . format ( record ) __init__ ( class_length ) Initialize the LogFormatter with a specified class name length for formatting. Parameters: class_length ( int ) \u2013 The maximum length of the logger name to display in the log output. If the logger name exceeds this length, it will be truncated from the left. Notes The formatter will apply different colors to the log output based on the log level (e.g., TRACE, DEBUG, INFO, WARNING, ERROR, CRITICAL). The log format includes the timestamp, log level, logger name (formatted with bold), and the log message. Source code in src/decima/logger.py 11 12 13 14 15 16 17 18 19 20 21 22 23 def __init__ ( self , class_length : int ) -> None : \"\"\"Initialize the LogFormatter with a specified class name length for formatting. Args: class_length (int): The maximum length of the logger name to display in the log output. If the logger name exceeds this length, it will be truncated from the left. Notes: - The formatter will apply different colors to the log output based on the log level (e.g., TRACE, DEBUG, INFO, WARNING, ERROR, CRITICAL). - The log format includes the timestamp, log level, logger name (formatted with bold), and the log message. \"\"\" super () . __init__ () self . class_length : int = class_length format ( record ) Override the format method to apply color formatting based on log levels and truncate logger names if they exceed the specified class length. Source code in src/decima/logger.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def format ( self , record : logging . LogRecord ) -> str : \"\"\"Override the format method to apply color formatting based on log levels and truncate logger names if they exceed the specified class length.\"\"\" if len ( record . name ) > self . class_length : record . name = record . name [ - self . class_length :] formats = { 5 : f \" { self . cyan }{ self . fmt_str }{ self . reset } \" , logging . DEBUG : f \" { self . blue }{ self . fmt_str }{ self . reset } \" , logging . INFO : f \" { self . gray }{ self . fmt_str }{ self . reset } \" , logging . WARNING : f \" { self . yellow }{ self . fmt_str }{ self . reset } \" , logging . ERROR : f \" { self . red }{ self . fmt_str }{ self . reset } \" , logging . CRITICAL : f \" { self . bold_red }{ self . fmt_str }{ self . reset } \" , } log_fmt = formats . get ( record . levelno , self . fmt_str ) return logging . Formatter ( log_fmt ) . format ( record )","title":"API"},{"location":"api/#api-reference","text":"","title":"API Reference"},{"location":"api/#logger.CustomLogger","text":"Bases: Logger Custom logger that supports a TRACE level and sets up logging with both console and file handlers. Source code in src/decima/logger.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class CustomLogger ( logging . Logger ): \"\"\"Custom logger that supports a TRACE level and sets up logging with both console and file handlers.\"\"\" TRACE : ClassVar [ int ] = 5 logging . addLevelName ( TRACE , \"TRACE\" ) def trace ( self , msg : str , * args : Any , ** kwargs : Any ) -> None : # noqa: ANN401 \"\"\"Log a message with severity 'TRACE'.\"\"\" if self . isEnabledFor ( self . TRACE ): self . _log ( self . TRACE , msg , args , ** kwargs ) @staticmethod def setup_logging ( folder : str , filename : str , level : str , class_length : int ) -> None : \"\"\"Set up logging with a handler that uses the custom LogFormatter and a file handler that writes logs in JSON format using the JsonFormatter. Args: folder (str): The directory where log files will be stored. If the directory does not exist, it will be created. filename (str): The base name for the log files. The actual log file will include a timestamp to ensure uniqueness. level (str): The logging level (e.g., \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\") that determines the minimum severity of messages to be logged. class_length (int): The maximum length of the logger name to display in the log output. If the logger name exceeds this length, it will be truncated from the left. Description: - This method configures the logging system to use a custom logger class (CustomLogger) and sets up two handlers: a console handler that formats logs with colors based on log levels, and \"\"\" logging . setLoggerClass ( CustomLogger ) root : logging . Logger = logging . getLogger () for handler in root . handlers [:]: root . removeHandler ( handler ) log_dir = Path ( folder ) log_dir . mkdir ( parents = True , exist_ok = True ) date_time : str = datetime . now ( tz = datetime . now () . astimezone () . tzinfo ) . strftime ( \"%Y%m %d -%H%M%S\" ) file_handler = logging . FileHandler ( log_dir / f \" { filename } - { date_time } .log\" , mode = \"w\" ) file_handler . setFormatter ( logging . Formatter ( LogFormatter . fmt_str )) console_handler : logging . StreamHandler [ TextIO ] = logging . StreamHandler () console_handler . setFormatter ( LogFormatter ( class_length )) log_path : Path = Path ( folder ) / f \" { filename } .jsonl\" file_h = logging . FileHandler ( log_path , mode = \"a\" ) file_h . setFormatter ( JsonFormatter ()) logging . basicConfig ( level = level , handlers = [ console_handler , file_handler , file_h ])","title":"CustomLogger"},{"location":"api/#logger.CustomLogger.setup_logging","text":"Set up logging with a handler that uses the custom LogFormatter and a file handler that writes logs in JSON format using the JsonFormatter. Parameters: folder ( str ) \u2013 The directory where log files will be stored. If the directory does not exist, it will be created. filename ( str ) \u2013 The base name for the log files. The actual log file will include a timestamp to ensure uniqueness. level ( str ) \u2013 The logging level (e.g., \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\") that determines the minimum severity of messages to be logged. class_length ( int ) \u2013 The maximum length of the logger name to display in the log output. If the logger name exceeds this length, it will be truncated from the left. Description This method configures the logging system to use a custom logger class (CustomLogger) and sets up two handlers: a console handler that formats logs with colors based on log levels, and Source code in src/decima/logger.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 @staticmethod def setup_logging ( folder : str , filename : str , level : str , class_length : int ) -> None : \"\"\"Set up logging with a handler that uses the custom LogFormatter and a file handler that writes logs in JSON format using the JsonFormatter. Args: folder (str): The directory where log files will be stored. If the directory does not exist, it will be created. filename (str): The base name for the log files. The actual log file will include a timestamp to ensure uniqueness. level (str): The logging level (e.g., \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\") that determines the minimum severity of messages to be logged. class_length (int): The maximum length of the logger name to display in the log output. If the logger name exceeds this length, it will be truncated from the left. Description: - This method configures the logging system to use a custom logger class (CustomLogger) and sets up two handlers: a console handler that formats logs with colors based on log levels, and \"\"\" logging . setLoggerClass ( CustomLogger ) root : logging . Logger = logging . getLogger () for handler in root . handlers [:]: root . removeHandler ( handler ) log_dir = Path ( folder ) log_dir . mkdir ( parents = True , exist_ok = True ) date_time : str = datetime . now ( tz = datetime . now () . astimezone () . tzinfo ) . strftime ( \"%Y%m %d -%H%M%S\" ) file_handler = logging . FileHandler ( log_dir / f \" { filename } - { date_time } .log\" , mode = \"w\" ) file_handler . setFormatter ( logging . Formatter ( LogFormatter . fmt_str )) console_handler : logging . StreamHandler [ TextIO ] = logging . StreamHandler () console_handler . setFormatter ( LogFormatter ( class_length )) log_path : Path = Path ( folder ) / f \" { filename } .jsonl\" file_h = logging . FileHandler ( log_path , mode = \"a\" ) file_h . setFormatter ( JsonFormatter ()) logging . basicConfig ( level = level , handlers = [ console_handler , file_handler , file_h ])","title":"setup_logging"},{"location":"api/#logger.CustomLogger.trace","text":"Log a message with severity 'TRACE'. Source code in src/decima/logger.py 82 83 84 85 def trace ( self , msg : str , * args : Any , ** kwargs : Any ) -> None : # noqa: ANN401 \"\"\"Log a message with severity 'TRACE'.\"\"\" if self . isEnabledFor ( self . TRACE ): self . _log ( self . TRACE , msg , args , ** kwargs )","title":"trace"},{"location":"api/#logger.JsonFormatter","text":"Bases: Formatter Log formatter that outputs logs in JSON format, including timestamp, level, name, message, and any extra data. Source code in src/decima/logger.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class JsonFormatter ( logging . Formatter ): \"\"\"Log formatter that outputs logs in JSON format, including timestamp, level, name, message, and any extra data.\"\"\" def format ( self , record : logging . LogRecord ) -> str : \"\"\"Format the log record as a JSON string, including timestamp, level, name, message, and any extra data if provided.\"\"\" log_record : dict [ str , Any ] = { \"timestamp\" : datetime . fromtimestamp ( record . created , tz = datetime . now () . astimezone () . tzinfo ) . isoformat (), \"level\" : record . levelname , \"name\" : record . name , \"message\" : record . getMessage (), } # If the user passed extra={} data, include it if hasattr ( record , \"extra_data\" ): log_record [ \"extra\" ] = getattr ( record , \"extra_data\" , None ) return json . dumps ( log_record )","title":"JsonFormatter"},{"location":"api/#logger.JsonFormatter.format","text":"Format the log record as a JSON string, including timestamp, level, name, message, and any extra data if provided. Source code in src/decima/logger.py 61 62 63 64 65 66 67 68 69 70 71 72 73 def format ( self , record : logging . LogRecord ) -> str : \"\"\"Format the log record as a JSON string, including timestamp, level, name, message, and any extra data if provided.\"\"\" log_record : dict [ str , Any ] = { \"timestamp\" : datetime . fromtimestamp ( record . created , tz = datetime . now () . astimezone () . tzinfo ) . isoformat (), \"level\" : record . levelname , \"name\" : record . name , \"message\" : record . getMessage (), } # If the user passed extra={} data, include it if hasattr ( record , \"extra_data\" ): log_record [ \"extra\" ] = getattr ( record , \"extra_data\" , None ) return json . dumps ( log_record )","title":"format"},{"location":"api/#logger.LogFormatter","text":"Bases: Formatter Log formatter that adds colors based on log levels. Source code in src/decima/logger.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class LogFormatter ( logging . Formatter ): \"\"\"Log formatter that adds colors based on log levels.\"\"\" def __init__ ( self , class_length : int ) -> None : \"\"\"Initialize the LogFormatter with a specified class name length for formatting. Args: class_length (int): The maximum length of the logger name to display in the log output. If the logger name exceeds this length, it will be truncated from the left. Notes: - The formatter will apply different colors to the log output based on the log level (e.g., TRACE, DEBUG, INFO, WARNING, ERROR, CRITICAL). - The log format includes the timestamp, log level, logger name (formatted with bold), and the log message. \"\"\" super () . __init__ () self . class_length : int = class_length cyan , blue , gray , yellow , red , bold_red = ( \" \\x1b [36m\" , \" \\x1b [34m\" , \" \\x1b [37m\" , \" \\x1b [33m\" , \" \\x1b [31m\" , \" \\x1b [31;1m\" , ) reset = \" \\x1b [0m\" bold = \" \\033 [1m\" reset_bold = \" \\033 [0m\" fmt_str = f \"%(asctime)s - [%(levelname)s] - { bold } %(name)s { reset_bold } - %(message)s\" def format ( self , record : logging . LogRecord ) -> str : \"\"\"Override the format method to apply color formatting based on log levels and truncate logger names if they exceed the specified class length.\"\"\" if len ( record . name ) > self . class_length : record . name = record . name [ - self . class_length :] formats = { 5 : f \" { self . cyan }{ self . fmt_str }{ self . reset } \" , logging . DEBUG : f \" { self . blue }{ self . fmt_str }{ self . reset } \" , logging . INFO : f \" { self . gray }{ self . fmt_str }{ self . reset } \" , logging . WARNING : f \" { self . yellow }{ self . fmt_str }{ self . reset } \" , logging . ERROR : f \" { self . red }{ self . fmt_str }{ self . reset } \" , logging . CRITICAL : f \" { self . bold_red }{ self . fmt_str }{ self . reset } \" , } log_fmt = formats . get ( record . levelno , self . fmt_str ) return logging . Formatter ( log_fmt ) . format ( record )","title":"LogFormatter"},{"location":"api/#logger.LogFormatter.__init__","text":"Initialize the LogFormatter with a specified class name length for formatting. Parameters: class_length ( int ) \u2013 The maximum length of the logger name to display in the log output. If the logger name exceeds this length, it will be truncated from the left. Notes The formatter will apply different colors to the log output based on the log level (e.g., TRACE, DEBUG, INFO, WARNING, ERROR, CRITICAL). The log format includes the timestamp, log level, logger name (formatted with bold), and the log message. Source code in src/decima/logger.py 11 12 13 14 15 16 17 18 19 20 21 22 23 def __init__ ( self , class_length : int ) -> None : \"\"\"Initialize the LogFormatter with a specified class name length for formatting. Args: class_length (int): The maximum length of the logger name to display in the log output. If the logger name exceeds this length, it will be truncated from the left. Notes: - The formatter will apply different colors to the log output based on the log level (e.g., TRACE, DEBUG, INFO, WARNING, ERROR, CRITICAL). - The log format includes the timestamp, log level, logger name (formatted with bold), and the log message. \"\"\" super () . __init__ () self . class_length : int = class_length","title":"__init__"},{"location":"api/#logger.LogFormatter.format","text":"Override the format method to apply color formatting based on log levels and truncate logger names if they exceed the specified class length. Source code in src/decima/logger.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def format ( self , record : logging . LogRecord ) -> str : \"\"\"Override the format method to apply color formatting based on log levels and truncate logger names if they exceed the specified class length.\"\"\" if len ( record . name ) > self . class_length : record . name = record . name [ - self . class_length :] formats = { 5 : f \" { self . cyan }{ self . fmt_str }{ self . reset } \" , logging . DEBUG : f \" { self . blue }{ self . fmt_str }{ self . reset } \" , logging . INFO : f \" { self . gray }{ self . fmt_str }{ self . reset } \" , logging . WARNING : f \" { self . yellow }{ self . fmt_str }{ self . reset } \" , logging . ERROR : f \" { self . red }{ self . fmt_str }{ self . reset } \" , logging . CRITICAL : f \" { self . bold_red }{ self . fmt_str }{ self . reset } \" , } log_fmt = formats . get ( record . levelno , self . fmt_str ) return logging . Formatter ( log_fmt ) . format ( record )","title":"format"}]}